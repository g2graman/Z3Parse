# Generated from java-escape by ANTLR 4.5
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO
package = globals().get("__package__", None)
ischild = len(package)>0 if package is not None else False
if ischild:
    from .Z3proofListener import Z3proofListener
else:
    from Z3proofListener import Z3proofListener
def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
        buf.write(u"8v\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4")
        buf.write(u"\b\t\b\3\2\3\2\3\2\5\2\24\n\2\3\2\3\2\3\2\3\3\3\3\3\3")
        buf.write(u"\3\3\3\3\5\3\36\n\3\3\4\3\4\3\5\3\5\3\5\7\5%\n\5\f\5")
        buf.write(u"\16\5(\13\5\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\7\6\62\n")
        buf.write(u"\6\f\6\16\6\65\13\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write(u"\6\7\6@\n\6\f\6\16\6C\13\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write(u"\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write(u"\6\3\6\3\6\5\6[\n\6\3\6\3\6\3\6\3\6\3\6\3\6\7\6c\n\6")
        buf.write(u"\f\6\16\6f\13\6\3\7\3\7\3\7\7\7k\n\7\f\7\16\7n\13\7\3")
        buf.write(u"\b\3\b\5\br\n\b\3\b\3\b\3\b\2\3\n\t\2\4\6\b\n\f\16\2")
        buf.write(u"\3\3\2\b\'}\2\20\3\2\2\2\4\35\3\2\2\2\6\37\3\2\2\2\b")
        buf.write(u"!\3\2\2\2\nZ\3\2\2\2\fg\3\2\2\2\16o\3\2\2\2\20\21\7(")
        buf.write(u"\2\2\21\23\7\7\2\2\22\24\5\4\3\2\23\22\3\2\2\2\23\24")
        buf.write(u"\3\2\2\2\24\25\3\2\2\2\25\26\7)\2\2\26\27\7\2\2\3\27")
        buf.write(u"\3\3\2\2\2\30\31\7(\2\2\31\32\5\b\5\2\32\33\7)\2\2\33")
        buf.write(u"\36\3\2\2\2\34\36\5\b\5\2\35\30\3\2\2\2\35\34\3\2\2\2")
        buf.write(u"\36\5\3\2\2\2\37 \t\2\2\2 \7\3\2\2\2!&\5\6\4\2\"#\7*")
        buf.write(u"\2\2#%\5\6\4\2$\"\3\2\2\2%(\3\2\2\2&$\3\2\2\2&\'\3\2")
        buf.write(u"\2\2\'\t\3\2\2\2(&\3\2\2\2)*\b\6\1\2*+\7\3\2\2+,\7(\2")
        buf.write(u"\2,-\5\n\6\2-.\7*\2\2.\63\5\n\6\2/\60\7*\2\2\60\62\5")
        buf.write(u"\n\6\2\61/\3\2\2\2\62\65\3\2\2\2\63\61\3\2\2\2\63\64")
        buf.write(u"\3\2\2\2\64\66\3\2\2\2\65\63\3\2\2\2\66\67\7)\2\2\67")
        buf.write(u"[\3\2\2\289\7\4\2\29:\7(\2\2:;\5\n\6\2;<\7*\2\2<A\5\n")
        buf.write(u"\6\2=>\7*\2\2>@\5\n\6\2?=\3\2\2\2@C\3\2\2\2A?\3\2\2\2")
        buf.write(u"AB\3\2\2\2BD\3\2\2\2CA\3\2\2\2DE\7)\2\2E[\3\2\2\2FG\7")
        buf.write(u"\5\2\2GH\7(\2\2HI\5\n\6\2IJ\7*\2\2JK\5\n\6\2KL\7)\2\2")
        buf.write(u"L[\3\2\2\2MN\7\6\2\2NO\7(\2\2OP\5\n\6\2PQ\7*\2\2QR\5")
        buf.write(u"\n\6\2RS\7*\2\2ST\5\n\6\2TU\7)\2\2U[\3\2\2\2V[\78\2\2")
        buf.write(u"W[\7\64\2\2XY\78\2\2Y[\5\16\b\2Z)\3\2\2\2Z8\3\2\2\2Z")
        buf.write(u"F\3\2\2\2ZM\3\2\2\2ZV\3\2\2\2ZW\3\2\2\2ZX\3\2\2\2[d\3")
        buf.write(u"\2\2\2\\]\f\13\2\2]^\7\65\2\2^c\5\n\6\f_`\f\n\2\2`a\7")
        buf.write(u"\66\2\2ac\5\n\6\13b\\\3\2\2\2b_\3\2\2\2cf\3\2\2\2db\3")
        buf.write(u"\2\2\2de\3\2\2\2e\13\3\2\2\2fd\3\2\2\2gl\5\n\6\2hi\7")
        buf.write(u"*\2\2ik\5\n\6\2jh\3\2\2\2kn\3\2\2\2lj\3\2\2\2lm\3\2\2")
        buf.write(u"\2m\r\3\2\2\2nl\3\2\2\2oq\7(\2\2pr\5\f\7\2qp\3\2\2\2")
        buf.write(u"qr\3\2\2\2rs\3\2\2\2st\7)\2\2t\17\3\2\2\2\f\23\35&\63")
        buf.write(u"AZbdlq")
        return buf.getvalue()


class Z3proofParser ( Parser ):

    grammarFileName = "java-escape"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'And'", u"'Or'", u"'Implies'", u"'If'", 
                     u"'goal'", u"'asserted'", u"'apply-def'", u"'commutativity'", 
                     u"'monotonicity'", u"'def-axiom'", u"'der'", u"'distributivity'", 
                     u"'and-elim'", u"'not-or-elim'", u"'elim-unused'", 
                     u"'hypothesis'", u"'iff-false'", u"'iff-true'", u"'iff~'", 
                     u"'quant-inst'", u"'quant-intro'", u"'intro-def'", 
                     u"'lemma'", u"'nnf-neg'", u"'nnf-pos'", u"'mp'", u"'mp~'", 
                     u"'pull-quant'", u"'push-quant'", u"'refl'", u"'rewrite'", 
                     u"'sk'", u"'symm'", u"'th-lemma'", u"'trans'", u"'true-axiom'", 
                     u"'unit-resolution'", u"'('", u"')'", u"','" ]

    symbolicNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"GOAL", u"ASSERT", u"APPLY_DEF", u"COMMUTATIVITY", 
                      u"MONOTONICITY", u"DEF_AXIOM", u"DER", u"DISTRIBUTIVITY", 
                      u"AND_ELIM", u"NOT_OR_ELIM", u"ELIM_UNUSED", u"HYPOTHESIS", 
                      u"IFF_FALSE", u"IFF_TRUE", u"IFF_OTHER", u"QUANT_INST", 
                      u"QUANT_INTRO", u"INTRO_DEF", u"LEMMA", u"NNF_NEG", 
                      u"NNF_POS", u"MP", u"MP_OTHER", u"PULL_QUANT", u"PUSH_QUANT", 
                      u"REFLEXIVITY", u"REWRITE", u"SKOLEM", u"SYMMETRY", 
                      u"TH_LEMMA", u"TRANSITIVITY", u"TRUE_AXIOM", u"UNIT_RESOLUTION", 
                      u"LEFT_PAREN", u"RIGHT_PAREN", u"COMMA", u"LOWERCASE", 
                      u"UPPERCASE", u"ALPHA", u"ALPHANUMERIC", u"DIGIT", 
                      u"INTEGER", u"FLOAT", u"NUMERICAL_LITERAL", u"BOOLEAN_LITERAL", 
                      u"LITERAL", u"ARITHMETIC_OPERATOR", u"COMPARISON_OPERATOR", 
                      u"WHITESPACE", u"IDENTIFIER" ]

    RULE_proof = 0
    RULE_rules = 1
    RULE_proof_rule = 2
    RULE_ruleList = 3
    RULE_expression = 4
    RULE_argumentList = 5
    RULE_arguments = 6

    ruleNames =  [ u"proof", u"rules", u"proof_rule", u"ruleList", u"expression", 
                   u"argumentList", u"arguments" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    GOAL=5
    ASSERT=6
    APPLY_DEF=7
    COMMUTATIVITY=8
    MONOTONICITY=9
    DEF_AXIOM=10
    DER=11
    DISTRIBUTIVITY=12
    AND_ELIM=13
    NOT_OR_ELIM=14
    ELIM_UNUSED=15
    HYPOTHESIS=16
    IFF_FALSE=17
    IFF_TRUE=18
    IFF_OTHER=19
    QUANT_INST=20
    QUANT_INTRO=21
    INTRO_DEF=22
    LEMMA=23
    NNF_NEG=24
    NNF_POS=25
    MP=26
    MP_OTHER=27
    PULL_QUANT=28
    PUSH_QUANT=29
    REFLEXIVITY=30
    REWRITE=31
    SKOLEM=32
    SYMMETRY=33
    TH_LEMMA=34
    TRANSITIVITY=35
    TRUE_AXIOM=36
    UNIT_RESOLUTION=37
    LEFT_PAREN=38
    RIGHT_PAREN=39
    COMMA=40
    LOWERCASE=41
    UPPERCASE=42
    ALPHA=43
    ALPHANUMERIC=44
    DIGIT=45
    INTEGER=46
    FLOAT=47
    NUMERICAL_LITERAL=48
    BOOLEAN_LITERAL=49
    LITERAL=50
    ARITHMETIC_OPERATOR=51
    COMPARISON_OPERATOR=52
    WHITESPACE=53
    IDENTIFIER=54

    def __init__(self, input):
        super(Z3proofParser, self).__init__(input)
        self.checkVersion("4.5")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProofContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(Z3proofParser.ProofContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(Z3proofParser.LEFT_PAREN, 0)

        def GOAL(self):
            return self.getToken(Z3proofParser.GOAL, 0)

        def RIGHT_PAREN(self):
            return self.getToken(Z3proofParser.RIGHT_PAREN, 0)

        def EOF(self):
            return self.getToken(Z3proofParser.EOF, 0)

        def rules(self):
            return self.getTypedRuleContext(Z3proofParser.RulesContext,0)


        def getRuleIndex(self):
            return Z3proofParser.RULE_proof

        def enterRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.enterProof(self)

        def exitRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.exitProof(self)




    def proof(self):

        localctx = Z3proofParser.ProofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_proof)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 14
            self.match(Z3proofParser.LEFT_PAREN)
            self.state = 15
            self.match(Z3proofParser.GOAL)
            self.state = 17
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << Z3proofParser.ASSERT) | (1 << Z3proofParser.APPLY_DEF) | (1 << Z3proofParser.COMMUTATIVITY) | (1 << Z3proofParser.MONOTONICITY) | (1 << Z3proofParser.DEF_AXIOM) | (1 << Z3proofParser.DER) | (1 << Z3proofParser.DISTRIBUTIVITY) | (1 << Z3proofParser.AND_ELIM) | (1 << Z3proofParser.NOT_OR_ELIM) | (1 << Z3proofParser.ELIM_UNUSED) | (1 << Z3proofParser.HYPOTHESIS) | (1 << Z3proofParser.IFF_FALSE) | (1 << Z3proofParser.IFF_TRUE) | (1 << Z3proofParser.IFF_OTHER) | (1 << Z3proofParser.QUANT_INST) | (1 << Z3proofParser.QUANT_INTRO) | (1 << Z3proofParser.INTRO_DEF) | (1 << Z3proofParser.LEMMA) | (1 << Z3proofParser.NNF_NEG) | (1 << Z3proofParser.NNF_POS) | (1 << Z3proofParser.MP) | (1 << Z3proofParser.MP_OTHER) | (1 << Z3proofParser.PULL_QUANT) | (1 << Z3proofParser.PUSH_QUANT) | (1 << Z3proofParser.REFLEXIVITY) | (1 << Z3proofParser.REWRITE) | (1 << Z3proofParser.SKOLEM) | (1 << Z3proofParser.SYMMETRY) | (1 << Z3proofParser.TH_LEMMA) | (1 << Z3proofParser.TRANSITIVITY) | (1 << Z3proofParser.TRUE_AXIOM) | (1 << Z3proofParser.UNIT_RESOLUTION) | (1 << Z3proofParser.LEFT_PAREN))) != 0):
                self.state = 16
                self.rules()


            self.state = 19
            self.match(Z3proofParser.RIGHT_PAREN)
            self.state = 20
            self.match(Z3proofParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RulesContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(Z3proofParser.RulesContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(Z3proofParser.LEFT_PAREN, 0)

        def ruleList(self):
            return self.getTypedRuleContext(Z3proofParser.RuleListContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(Z3proofParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return Z3proofParser.RULE_rules

        def enterRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.enterRules(self)

        def exitRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.exitRules(self)




    def rules(self):

        localctx = Z3proofParser.RulesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_rules)
        try:
            self.state = 27
            token = self._input.LA(1)
            if token in [Z3proofParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 22
                self.match(Z3proofParser.LEFT_PAREN)
                self.state = 23
                self.ruleList()
                self.state = 24
                self.match(Z3proofParser.RIGHT_PAREN)

            elif token in [Z3proofParser.ASSERT, Z3proofParser.APPLY_DEF, Z3proofParser.COMMUTATIVITY, Z3proofParser.MONOTONICITY, Z3proofParser.DEF_AXIOM, Z3proofParser.DER, Z3proofParser.DISTRIBUTIVITY, Z3proofParser.AND_ELIM, Z3proofParser.NOT_OR_ELIM, Z3proofParser.ELIM_UNUSED, Z3proofParser.HYPOTHESIS, Z3proofParser.IFF_FALSE, Z3proofParser.IFF_TRUE, Z3proofParser.IFF_OTHER, Z3proofParser.QUANT_INST, Z3proofParser.QUANT_INTRO, Z3proofParser.INTRO_DEF, Z3proofParser.LEMMA, Z3proofParser.NNF_NEG, Z3proofParser.NNF_POS, Z3proofParser.MP, Z3proofParser.MP_OTHER, Z3proofParser.PULL_QUANT, Z3proofParser.PUSH_QUANT, Z3proofParser.REFLEXIVITY, Z3proofParser.REWRITE, Z3proofParser.SKOLEM, Z3proofParser.SYMMETRY, Z3proofParser.TH_LEMMA, Z3proofParser.TRANSITIVITY, Z3proofParser.TRUE_AXIOM, Z3proofParser.UNIT_RESOLUTION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 26
                self.ruleList()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Proof_ruleContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(Z3proofParser.Proof_ruleContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ASSERT(self):
            return self.getToken(Z3proofParser.ASSERT, 0)

        def APPLY_DEF(self):
            return self.getToken(Z3proofParser.APPLY_DEF, 0)

        def COMMUTATIVITY(self):
            return self.getToken(Z3proofParser.COMMUTATIVITY, 0)

        def MONOTONICITY(self):
            return self.getToken(Z3proofParser.MONOTONICITY, 0)

        def DEF_AXIOM(self):
            return self.getToken(Z3proofParser.DEF_AXIOM, 0)

        def DER(self):
            return self.getToken(Z3proofParser.DER, 0)

        def DISTRIBUTIVITY(self):
            return self.getToken(Z3proofParser.DISTRIBUTIVITY, 0)

        def AND_ELIM(self):
            return self.getToken(Z3proofParser.AND_ELIM, 0)

        def NOT_OR_ELIM(self):
            return self.getToken(Z3proofParser.NOT_OR_ELIM, 0)

        def ELIM_UNUSED(self):
            return self.getToken(Z3proofParser.ELIM_UNUSED, 0)

        def HYPOTHESIS(self):
            return self.getToken(Z3proofParser.HYPOTHESIS, 0)

        def IFF_FALSE(self):
            return self.getToken(Z3proofParser.IFF_FALSE, 0)

        def IFF_TRUE(self):
            return self.getToken(Z3proofParser.IFF_TRUE, 0)

        def IFF_OTHER(self):
            return self.getToken(Z3proofParser.IFF_OTHER, 0)

        def QUANT_INST(self):
            return self.getToken(Z3proofParser.QUANT_INST, 0)

        def QUANT_INTRO(self):
            return self.getToken(Z3proofParser.QUANT_INTRO, 0)

        def INTRO_DEF(self):
            return self.getToken(Z3proofParser.INTRO_DEF, 0)

        def LEMMA(self):
            return self.getToken(Z3proofParser.LEMMA, 0)

        def NNF_NEG(self):
            return self.getToken(Z3proofParser.NNF_NEG, 0)

        def NNF_POS(self):
            return self.getToken(Z3proofParser.NNF_POS, 0)

        def MP(self):
            return self.getToken(Z3proofParser.MP, 0)

        def MP_OTHER(self):
            return self.getToken(Z3proofParser.MP_OTHER, 0)

        def PULL_QUANT(self):
            return self.getToken(Z3proofParser.PULL_QUANT, 0)

        def PUSH_QUANT(self):
            return self.getToken(Z3proofParser.PUSH_QUANT, 0)

        def REFLEXIVITY(self):
            return self.getToken(Z3proofParser.REFLEXIVITY, 0)

        def REWRITE(self):
            return self.getToken(Z3proofParser.REWRITE, 0)

        def SKOLEM(self):
            return self.getToken(Z3proofParser.SKOLEM, 0)

        def SYMMETRY(self):
            return self.getToken(Z3proofParser.SYMMETRY, 0)

        def TH_LEMMA(self):
            return self.getToken(Z3proofParser.TH_LEMMA, 0)

        def TRANSITIVITY(self):
            return self.getToken(Z3proofParser.TRANSITIVITY, 0)

        def TRUE_AXIOM(self):
            return self.getToken(Z3proofParser.TRUE_AXIOM, 0)

        def UNIT_RESOLUTION(self):
            return self.getToken(Z3proofParser.UNIT_RESOLUTION, 0)

        def getRuleIndex(self):
            return Z3proofParser.RULE_proof_rule

        def enterRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.enterProof_rule(self)

        def exitRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.exitProof_rule(self)




    def proof_rule(self):

        localctx = Z3proofParser.Proof_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_proof_rule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 29
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << Z3proofParser.ASSERT) | (1 << Z3proofParser.APPLY_DEF) | (1 << Z3proofParser.COMMUTATIVITY) | (1 << Z3proofParser.MONOTONICITY) | (1 << Z3proofParser.DEF_AXIOM) | (1 << Z3proofParser.DER) | (1 << Z3proofParser.DISTRIBUTIVITY) | (1 << Z3proofParser.AND_ELIM) | (1 << Z3proofParser.NOT_OR_ELIM) | (1 << Z3proofParser.ELIM_UNUSED) | (1 << Z3proofParser.HYPOTHESIS) | (1 << Z3proofParser.IFF_FALSE) | (1 << Z3proofParser.IFF_TRUE) | (1 << Z3proofParser.IFF_OTHER) | (1 << Z3proofParser.QUANT_INST) | (1 << Z3proofParser.QUANT_INTRO) | (1 << Z3proofParser.INTRO_DEF) | (1 << Z3proofParser.LEMMA) | (1 << Z3proofParser.NNF_NEG) | (1 << Z3proofParser.NNF_POS) | (1 << Z3proofParser.MP) | (1 << Z3proofParser.MP_OTHER) | (1 << Z3proofParser.PULL_QUANT) | (1 << Z3proofParser.PUSH_QUANT) | (1 << Z3proofParser.REFLEXIVITY) | (1 << Z3proofParser.REWRITE) | (1 << Z3proofParser.SKOLEM) | (1 << Z3proofParser.SYMMETRY) | (1 << Z3proofParser.TH_LEMMA) | (1 << Z3proofParser.TRANSITIVITY) | (1 << Z3proofParser.TRUE_AXIOM) | (1 << Z3proofParser.UNIT_RESOLUTION))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RuleListContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(Z3proofParser.RuleListContext, self).__init__(parent, invokingState)
            self.parser = parser

        def proof_rule(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(Z3proofParser.Proof_ruleContext)
            else:
                return self.getTypedRuleContext(Z3proofParser.Proof_ruleContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(Z3proofParser.COMMA)
            else:
                return self.getToken(Z3proofParser.COMMA, i)

        def getRuleIndex(self):
            return Z3proofParser.RULE_ruleList

        def enterRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.enterRuleList(self)

        def exitRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.exitRuleList(self)




    def ruleList(self):

        localctx = Z3proofParser.RuleListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_ruleList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 31
            self.proof_rule()
            self.state = 36
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==Z3proofParser.COMMA:
                self.state = 32
                self.match(Z3proofParser.COMMA)
                self.state = 33
                self.proof_rule()
                self.state = 38
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(Z3proofParser.ExpressionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(Z3proofParser.LEFT_PAREN, 0)

        def expression(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(Z3proofParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(Z3proofParser.ExpressionContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(Z3proofParser.COMMA)
            else:
                return self.getToken(Z3proofParser.COMMA, i)

        def RIGHT_PAREN(self):
            return self.getToken(Z3proofParser.RIGHT_PAREN, 0)

        def IDENTIFIER(self):
            return self.getToken(Z3proofParser.IDENTIFIER, 0)

        def LITERAL(self):
            return self.getToken(Z3proofParser.LITERAL, 0)

        def arguments(self):
            return self.getTypedRuleContext(Z3proofParser.ArgumentsContext,0)


        def ARITHMETIC_OPERATOR(self):
            return self.getToken(Z3proofParser.ARITHMETIC_OPERATOR, 0)

        def COMPARISON_OPERATOR(self):
            return self.getToken(Z3proofParser.COMPARISON_OPERATOR, 0)

        def getRuleIndex(self):
            return Z3proofParser.RULE_expression

        def enterRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.enterExpression(self)

        def exitRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.exitExpression(self)



    def expression(self, _p=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = Z3proofParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 8
        self.enterRecursionRule(localctx, 8, self.RULE_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 88
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 40
                self.match(Z3proofParser.T__0)
                self.state = 41
                self.match(Z3proofParser.LEFT_PAREN)
                self.state = 42
                self.expression(0)
                self.state = 43
                self.match(Z3proofParser.COMMA)
                self.state = 44
                self.expression(0)
                self.state = 49
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==Z3proofParser.COMMA:
                    self.state = 45
                    self.match(Z3proofParser.COMMA)
                    self.state = 46
                    self.expression(0)
                    self.state = 51
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 52
                self.match(Z3proofParser.RIGHT_PAREN)
                pass

            elif la_ == 2:
                self.state = 54
                self.match(Z3proofParser.T__1)
                self.state = 55
                self.match(Z3proofParser.LEFT_PAREN)
                self.state = 56
                self.expression(0)
                self.state = 57
                self.match(Z3proofParser.COMMA)
                self.state = 58
                self.expression(0)
                self.state = 63
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==Z3proofParser.COMMA:
                    self.state = 59
                    self.match(Z3proofParser.COMMA)
                    self.state = 60
                    self.expression(0)
                    self.state = 65
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 66
                self.match(Z3proofParser.RIGHT_PAREN)
                pass

            elif la_ == 3:
                self.state = 68
                self.match(Z3proofParser.T__2)
                self.state = 69
                self.match(Z3proofParser.LEFT_PAREN)
                self.state = 70
                self.expression(0)
                self.state = 71
                self.match(Z3proofParser.COMMA)
                self.state = 72
                self.expression(0)
                self.state = 73
                self.match(Z3proofParser.RIGHT_PAREN)
                pass

            elif la_ == 4:
                self.state = 75
                self.match(Z3proofParser.T__3)
                self.state = 76
                self.match(Z3proofParser.LEFT_PAREN)
                self.state = 77
                self.expression(0)
                self.state = 78
                self.match(Z3proofParser.COMMA)
                self.state = 79
                self.expression(0)
                self.state = 80
                self.match(Z3proofParser.COMMA)
                self.state = 81
                self.expression(0)
                self.state = 82
                self.match(Z3proofParser.RIGHT_PAREN)
                pass

            elif la_ == 5:
                self.state = 84
                self.match(Z3proofParser.IDENTIFIER)
                pass

            elif la_ == 6:
                self.state = 85
                self.match(Z3proofParser.LITERAL)
                pass

            elif la_ == 7:
                self.state = 86
                self.match(Z3proofParser.IDENTIFIER)
                self.state = 87
                self.arguments()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 98
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,7,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 96
                    la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
                    if la_ == 1:
                        localctx = Z3proofParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 90
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 91
                        self.match(Z3proofParser.ARITHMETIC_OPERATOR)
                        self.state = 92
                        self.expression(10)
                        pass

                    elif la_ == 2:
                        localctx = Z3proofParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 93
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 94
                        self.match(Z3proofParser.COMPARISON_OPERATOR)
                        self.state = 95
                        self.expression(9)
                        pass

             
                self.state = 100
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ArgumentListContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(Z3proofParser.ArgumentListContext, self).__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(Z3proofParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(Z3proofParser.ExpressionContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(Z3proofParser.COMMA)
            else:
                return self.getToken(Z3proofParser.COMMA, i)

        def getRuleIndex(self):
            return Z3proofParser.RULE_argumentList

        def enterRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.enterArgumentList(self)

        def exitRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.exitArgumentList(self)




    def argumentList(self):

        localctx = Z3proofParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.expression(0)
            self.state = 106
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==Z3proofParser.COMMA:
                self.state = 102
                self.match(Z3proofParser.COMMA)
                self.state = 103
                self.expression(0)
                self.state = 108
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArgumentsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(Z3proofParser.ArgumentsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(Z3proofParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(Z3proofParser.RIGHT_PAREN, 0)

        def argumentList(self):
            return self.getTypedRuleContext(Z3proofParser.ArgumentListContext,0)


        def getRuleIndex(self):
            return Z3proofParser.RULE_arguments

        def enterRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.enterArguments(self)

        def exitRule(self, listener):
            if isinstance( listener, Z3proofListener ):
                listener.exitArguments(self)




    def arguments(self):

        localctx = Z3proofParser.ArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            self.match(Z3proofParser.LEFT_PAREN)
            self.state = 111
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << Z3proofParser.T__0) | (1 << Z3proofParser.T__1) | (1 << Z3proofParser.T__2) | (1 << Z3proofParser.T__3) | (1 << Z3proofParser.LITERAL) | (1 << Z3proofParser.IDENTIFIER))) != 0):
                self.state = 110
                self.argumentList()


            self.state = 113
            self.match(Z3proofParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx, ruleIndex, predIndex):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[4] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx, predIndex):
            if predIndex == 0:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 8)
         



